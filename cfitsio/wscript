# vim: set syntax=python:

# This wscript file merely calls out to the standard CFITSIO Makefile
# to build libcfitsio.a

import glob
import os

def configure(ctx):
    ctx.find_program('make')

    ctx.start_msg('Configuring cfitsio')
    ctx.exec_command('cd cfitsio; ./configure; cd ..')
    ctx.end_msg('done', 'GREEN')

    ctx.env.LIBPATH_CFITSIO = [os.path.abspath('cfitsio')]
    ctx.env.INCLUDES_CFITSIO = [os.path.abspath('cfitsio')]
    ctx.env.STLIB_CFITSIO = ['cfitsio']

def build(ctx):
    if ctx.cmd == 'clean':
        return clean(ctx)

    def run_makefile(task):
        # cd into the cfitsio directory, run 'make', step back out
        pwd = os.getcwd()
        cwd = os.path.join(ctx.srcnode.abspath(), 'cfitsio')
        task.exec_command('cd %s; make; cd %s' % (cwd, pwd))

        # copy the .a file to waf's build heirarchy so it knows
        # the build product has been created
        src = os.path.join(cwd, 'libcfitsio.a')
        dst = os.path.join(ctx.bldnode.abspath(), 'cfitsio')
        task.exec_command('cp %s %s' % (src, dst))

    # Just assume all .c and .h files in the cfitsio directory
    # contribute to libcfitsio.a.  The CFITSIO Makefile itself will
    # worry about the details
    sources = [
        os.path.basename(x) for x in
        glob.glob('cfitsio/*.c') + glob.glob('cfitsio/*.h')] + \
        ['configure']

    ctx(
        name='cfitsio',
        source=sources,
        target='libcfitsio.a',
        rule=run_makefile)

    # CFITSIO should be built before everything else.  This ensures
    # that.
    ctx.add_group()

def clean(ctx):
    pwd = os.getcwd()
    cwd = os.path.join(ctx.srcnode.abspath(), 'cfitsio')
    ctx.exec_command('cd %s; make clean; cd %s' % (cwd, pwd))
